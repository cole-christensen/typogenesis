import SwiftUI

// MARK: - View Model

@MainActor
final class CloneWizardViewModel: ObservableObject {
    enum WizardStep: Int, CaseIterable {
        case selectFont
        case analyzeStyle
        case selectCharacters
        case generate
        case complete

        var title: String {
            switch self {
            case .selectFont: return "Select"
            case .analyzeStyle: return "Analyze"
            case .selectCharacters: return "Characters"
            case .generate: return "Generate"
            case .complete: return "Complete"
            }
        }
    }

    @Published var currentStep: WizardStep = .selectFont
    @Published var referenceFont: FontProject?
    @Published var extractedStyle: StyleEncoder.FontStyle?
    @Published var isAnalyzing = false
    @Published var isGenerating = false
    @Published var errorMessage: String?

    @Published var generateUppercase = true
    @Published var generateLowercase = true
    @Published var generateDigits = true
    @Published var generatePunctuation = false

    @Published var generatedGlyphs: [Glyph] = []
    @Published var generationProgress: Double = 0
    @Published var currentGeneratingCharacter: String?
    @Published var isUsingTemplateFallback = false

    private let fontParser = FontParser()

    var canProceed: Bool {
        switch currentStep {
        case .selectFont:
            return referenceFont != nil
        case .analyzeStyle:
            return extractedStyle != nil && !isAnalyzing
        case .selectCharacters:
            return selectedCharacterCount > 0
        case .generate:
            return !generatedGlyphs.isEmpty && !isGenerating
        case .complete:
            return true
        }
    }

    var selectedCharacterCount: Int {
        var count = 0
        if generateUppercase { count += 26 }
        if generateLowercase { count += 26 }
        if generateDigits { count += 10 }
        if generatePunctuation { count += 14 }
        return count
    }

    /// Whether the generated glyphs are template-based placeholders (not real AI)
    var isUsingPlaceholders: Bool {
        guard !generatedGlyphs.isEmpty else { return false }
        // Check if ANY glyph was generated by real AI or style transfer
        let hasRealAI = generatedGlyphs.contains { glyph in
            glyph.generatedBy == .aiGenerated || glyph.generatedBy == .styleTransfer
        }
        return !hasRealAI
    }

    var selectedCharacters: [Character] {
        var chars: [Character] = []
        if generateUppercase {
            chars.append(contentsOf: Array("ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
        }
        if generateLowercase {
            chars.append(contentsOf: Array("abcdefghijklmnopqrstuvwxyz"))
        }
        if generateDigits {
            chars.append(contentsOf: Array("0123456789"))
        }
        if generatePunctuation {
            chars.append(contentsOf: Array(".,;:!?'\"()-–—…"))
        }
        return chars
    }

    func nextStep() {
        guard let nextIndex = WizardStep.allCases.firstIndex(where: { $0.rawValue == currentStep.rawValue + 1 }) else { return }
        currentStep = WizardStep.allCases[nextIndex]
    }

    func previousStep() {
        guard let prevIndex = WizardStep.allCases.firstIndex(where: { $0.rawValue == currentStep.rawValue - 1 }) else { return }
        currentStep = WizardStep.allCases[prevIndex]
    }

    func loadReferenceFont(from url: URL) async {
        errorMessage = nil

        do {
            referenceFont = try await fontParser.parse(url: url)
        } catch {
            errorMessage = "Failed to load font: \(error.localizedDescription)"
        }
    }

    func analyzeStyle() async {
        guard let font = referenceFont else { return }

        isAnalyzing = true
        errorMessage = nil

        // Run style extraction asynchronously
        let result: Result<StyleEncoder.FontStyle, Error> = await Task {
            let encoder = StyleEncoder()
            do {
                let style = try await encoder.extractStyle(from: font)
                return .success(style)
            } catch {
                return .failure(error)
            }
        }.value

        switch result {
        case .success(let style):
            extractedStyle = style
        case .failure(let error):
            errorMessage = "Failed to analyze style: \(error.localizedDescription)"
        }

        isAnalyzing = false
    }

    func generateGlyphs() async {
        guard let style = extractedStyle, let refFont = referenceFont else { return }

        isGenerating = true
        generatedGlyphs = []
        generationProgress = 0
        isUsingTemplateFallback = !GlyphGenerator.isModelAvailable()

        let characters = selectedCharacters
        let metrics = refFont.metrics

        // Generate using batch method asynchronously
        let result: Result<[GlyphGenerator.GenerationResult], Error> = await Task {
            let generator = GlyphGenerator()
            let mode = GlyphGenerator.GenerationMode.fromScratch(style: style)
            let settings = GlyphGenerator.GenerationSettings.default

            do {
                let results = try await generator.generateBatch(
                    characters: characters,
                    mode: mode,
                    metrics: metrics,
                    settings: settings
                ) { [weak self] completed, total in
                    Task { @MainActor [weak self] in
                        self?.generationProgress = Double(completed) / Double(total)
                        if completed < characters.count {
                            self?.currentGeneratingCharacter = String(characters[completed])
                        }
                    }
                }
                return .success(results)
            } catch {
                return .failure(error)
            }
        }.value

        switch result {
        case .success(let results):
            generatedGlyphs = results.map { $0.glyph }
        case .failure:
            // Create placeholders on failure
            generatedGlyphs = characters.map { character in
                Glyph(
                    character: character,
                    advanceWidth: metrics.unitsPerEm / 2,
                    leftSideBearing: metrics.unitsPerEm / 20,
                    generatedBy: .placeholder
                )
            }
        }

        currentGeneratingCharacter = nil
        isGenerating = false
        nextStep()  // Auto-advance to complete
    }

    func reset() {
        currentStep = .selectFont
        referenceFont = nil
        extractedStyle = nil
        generatedGlyphs = []
        generationProgress = 0
        errorMessage = nil
        isAnalyzing = false
        isGenerating = false
        isUsingTemplateFallback = false
    }
}
